<?php
/**
 * Plugin Name: OpenRouter Spam Filter
 * Description: Uses OpenRouter LLM to classify and flag spam comments automatically.
 * Version: 1.1.0
 * Author: lightnesscaster
 * Author URI: mailto:johnstondaniel4@gmail.com
 */

if (!defined('ABSPATH')) {
    exit;
}

class OpenRouter_Spam_Filter {
    private const MODELS = [
        'openai/gpt-oss-20b:free',
        'openai/gpt-oss-20b',
    ];

    private const MAX_ATTEMPTS_PER_MODEL = 2;
    private const REQUIRED_CONFIDENCE = 0.97;
    private const API_ENDPOINT = 'https://openrouter.ai/api/v1/chat/completions';
    private const SYSTEM_PROMPT = 'You are a deterministic classifier for blog comment spam. This is a book review blog.\n\nYour job: decide if a single comment is spam (unsolicited promotion, scam, link-dump, autogenerated junk) or not spam (legitimate human reply).\n\nFlag only when highly confident >= 0.97.';

    private const COMMENT_META_PENDING = '_openrouter_spam_filter_pending';
    private const COMMENT_META_ATTEMPTS = '_openrouter_spam_filter_attempts';
    private const COMMENT_META_NOTIFIED = '_openrouter_spam_filter_notified';
    private const COMMENT_META_ORIGINAL_STATUS = '_openrouter_spam_filter_original_status';
    private const MAX_QUEUE_RETRIES = 3;
    private const MAX_ACTIVE_WORKERS = 5;
    private const LOCK_RETRY_DELAY = 30; // seconds
    private const LOCK_FAILURE_BACKOFF = 300; // seconds
    private const LOCK_DIR_NAME = 'openrouter-spam-filter-locks';
    private const TRANSIENT_LOCK_KEY = 'openrouter_spam_filter_mutex';
    private const OPTION_IP_COUNTS = 'openrouter_spam_filter_ip_counts';
    private const ADMIN_PAGE_SLUG = 'openrouter-spam-filter';
    private const ADMIN_RECHECK_ACTION = 'openrouter_spam_filter_requeue';
    private const RETRY_DELAY = 120; // seconds

    private static array $lockHandles = [];
    private static bool $lockWarningLogged = false;

    public static function init(): void {
        add_action('comment_post', [__CLASS__, 'enqueue_comment_for_review'], 10, 2);
        add_action('openrouter_spam_filter_process_comment', [__CLASS__, 'process_queued_comment'], 10, 1);
        add_filter('comment_notification_recipients', [__CLASS__, 'suppress_notifications_for_pending'], 10, 2);
        add_filter('comment_moderation_recipients', [__CLASS__, 'suppress_notifications_for_pending'], 10, 2);
        add_filter('notify_moderator', [__CLASS__, 'maybe_disable_moderator_notification'], 10, 2);

        if (is_admin()) {
            add_action('admin_menu', [__CLASS__, 'register_settings_page']);
            add_action('admin_post_' . self::ADMIN_RECHECK_ACTION, [__CLASS__, 'handle_recheck_request']);
        }

        add_action('plugins_loaded', [__CLASS__, 'load_textdomain']);
    }

    private static function has_prior_approved_comment(int $comment_id): bool {
        $comment = get_comment($comment_id);
        if (!$comment) {
            return false;
        }

        $author_email = sanitize_email($comment->comment_author_email);
        if (empty($author_email)) {
            return false;
        }

        $normalized_email = strtolower($author_email);

        $count = get_comments([
            'author_email' => $normalized_email,
            'status' => 'approve',
            'count' => true,
            'fields' => 'ids',
        ]);

        return (int) $count > 0;
    }

    public static function enqueue_comment_for_review(int $comment_id, $comment_approved): void {
        self::queue_comment($comment_id, false);
    }

    public static function process_queued_comment(int $comment_id): void {
        $comment = get_comment($comment_id);
        if (!$comment) {
            self::clear_queue_state($comment_id);
            return;
        }

        $current_status = (string) $comment->comment_approved;

        if ($current_status === 'spam' || in_array($current_status, ['trash', 'post-trashed'], true)) {
            self::clear_queue_state($comment_id);
            return;
        }

        $original_status = (string) get_comment_meta($comment_id, self::COMMENT_META_ORIGINAL_STATUS, true);

        if ($current_status === '1' && $original_status !== '1') {
            self::clear_queue_state($comment_id);
            self::send_delayed_notifications($comment);
            return;
        }

        $lock_path = self::acquire_worker_slot();
        if ($lock_path === false) {
            $delay = self::jitter(self::LOCK_FAILURE_BACKOFF, 30);
            wp_schedule_single_event(time() + $delay, 'openrouter_spam_filter_process_comment', [$comment_id]);
            return;
        }

        if ($lock_path === null) {
            $delay = self::jitter(self::LOCK_RETRY_DELAY, 10);
            wp_schedule_single_event(time() + $delay, 'openrouter_spam_filter_process_comment', [$comment_id]);
            return;
        }

        try {
            $decision = self::classify_comment((string) $comment->comment_content);

            if ($decision && $decision['is_spam'] && $decision['confidence'] >= self::REQUIRED_CONFIDENCE) {
                if (wp_spam_comment($comment_id)) {
                    self::record_blocked_ip($comment);
                }
                self::clear_queue_state($comment_id);
                return;
            }

            if ($decision === null) {
                $attempts = (int) get_comment_meta($comment_id, self::COMMENT_META_ATTEMPTS, true);

                if ($attempts < self::MAX_QUEUE_RETRIES) {
                    update_comment_meta($comment_id, self::COMMENT_META_ATTEMPTS, $attempts + 1);
                    $delay = self::jitter(self::RETRY_DELAY, 15);
                    wp_schedule_single_event(time() + $delay, 'openrouter_spam_filter_process_comment', [$comment_id]);
                    return;
                }
            }

            self::clear_queue_state($comment_id);
            self::send_delayed_notifications($comment);
        } finally {
            self::release_worker_slot($lock_path);
        }
    }

    private static function clear_queue_state(int $comment_id): void {
        delete_comment_meta($comment_id, self::COMMENT_META_PENDING);
        delete_comment_meta($comment_id, self::COMMENT_META_ATTEMPTS);
        delete_comment_meta($comment_id, self::COMMENT_META_ORIGINAL_STATUS);
    }

    public static function suppress_notifications_for_pending(array $emails, $comment_id): array {
        $comment_id = (int) $comment_id;
        if ($comment_id > 0 && get_comment_meta($comment_id, self::COMMENT_META_PENDING, true)) {
            return [];
        }

        return $emails;
    }

    public static function maybe_disable_moderator_notification($notify, $comment_id) {
        $comment_id = (int) $comment_id;
        if ($notify && $comment_id > 0 && get_comment_meta($comment_id, self::COMMENT_META_PENDING, true)) {
            return false;
        }

        return (bool) $notify;
    }

    private static function queue_comment(int $comment_id, bool $force = false): bool {
        if (!$comment_id) {
            return false;
        }

        $comment = get_comment($comment_id);
        if (!$comment) {
            return false;
        }

        $status = (string) $comment->comment_approved;
        if ($status === 'spam' || in_array($status, ['trash', 'post-trashed'], true)) {
            return false;
        }

        if (!$force && self::has_prior_approved_comment($comment_id)) {
            return false;
        }

        update_comment_meta($comment_id, self::COMMENT_META_PENDING, current_time('mysql'));
        update_comment_meta($comment_id, self::COMMENT_META_ATTEMPTS, 0);

        if (!metadata_exists('comment', $comment_id, self::COMMENT_META_ORIGINAL_STATUS)) {
            update_comment_meta($comment_id, self::COMMENT_META_ORIGINAL_STATUS, $status);
        }

        delete_comment_meta($comment_id, self::COMMENT_META_NOTIFIED);

        wp_clear_scheduled_hook('openrouter_spam_filter_process_comment', [$comment_id]);
        wp_schedule_single_event(time(), 'openrouter_spam_filter_process_comment', [$comment_id]);

        return true;
    }

    private static function get_settings_page_url(): string {
        return admin_url('options-general.php?page=' . self::ADMIN_PAGE_SLUG);
    }

    public static function load_textdomain(): void {
        load_plugin_textdomain('openrouter-spam-filter', false, dirname(plugin_basename(__FILE__)) . '/languages');
    }

    public static function register_settings_page(): void {
        $title = __('OpenRouter Spam Filter', 'openrouter-spam-filter');

        add_options_page(
            $title,
            $title,
            'moderate_comments',
            self::ADMIN_PAGE_SLUG,
            [__CLASS__, 'render_settings_page']
        );
    }

    public static function render_settings_page(): void {
        if (!current_user_can('moderate_comments')) {
            wp_die(__('You do not have permission to access this page.', 'openrouter-spam-filter'));
        }

        $pending_count = get_comments([
            'status' => 'hold',
            'count' => true,
        ]);

        $message = isset($_GET['openrouter-msg']) ? sanitize_key((string) $_GET['openrouter-msg']) : '';
        $count = isset($_GET['count']) ? (int) $_GET['count'] : 0;

        echo '<div class="wrap">';
        echo '<h1>' . esc_html(get_admin_page_title()) . '</h1>';

        if ($message === 'requeued') {
            printf(
                '<div class="notice notice-success is-dismissible"><p>%s</p></div>',
                esc_html(sprintf(_n('%d pending comment was queued for re-check.', '%d pending comments were queued for re-check.', $count, 'openrouter-spam-filter'), $count))
            );
        } elseif ($message === 'none') {
            echo '<div class="notice notice-info is-dismissible"><p>' . esc_html__('No pending comments required re-checking.', 'openrouter-spam-filter') . '</p></div>';
        }

        echo '<p>' . esc_html(sprintf(_n('%d pending comment is awaiting moderation.', '%d pending comments are awaiting moderation.', (int) $pending_count, 'openrouter-spam-filter'), (int) $pending_count)) . '</p>';

        echo '<form method="post" action="' . esc_url(admin_url('admin-post.php')) . '">';
        wp_nonce_field(self::ADMIN_RECHECK_ACTION, '_openrouter_requeue_nonce');
        echo '<input type="hidden" name="action" value="' . esc_attr(self::ADMIN_RECHECK_ACTION) . '" />';
        echo '<p>' . esc_html__('Queue all pending comments for an immediate spam re-check using OpenRouter.', 'openrouter-spam-filter') . '</p>';
        submit_button(__('Re-check Pending Comments', 'openrouter-spam-filter'));
        echo '</form>';
        echo '</div>';
    }

    public static function handle_recheck_request(): void {
        if (!current_user_can('moderate_comments')) {
            wp_die(__('You do not have permission to perform this action.', 'openrouter-spam-filter'), 403);
        }

        check_admin_referer(self::ADMIN_RECHECK_ACTION, '_openrouter_requeue_nonce');

        $paged = 1;
        $per_page = 500;
        $queued = 0;

        do {
            $pending_ids = get_comments([
                'status' => 'hold',
                'fields' => 'ids',
                'number' => $per_page,
                'paged' => $paged,
            ]);

            foreach ($pending_ids as $comment_id) {
                if (self::queue_comment((int) $comment_id, true)) {
                    $queued++;
                }
            }

            $paged++;
        } while (!empty($pending_ids));

        $message = $queued > 0 ? 'requeued' : 'none';

        $redirect = add_query_arg(
            [
                'openrouter-msg' => $message,
                'count' => $queued,
            ],
            self::get_settings_page_url()
        );

        wp_safe_redirect($redirect);
        exit;
    }

    private static function send_delayed_notifications(\WP_Comment $comment): void {
        $comment_id = (int) $comment->comment_ID;

        if ((string) $comment->comment_approved === 'spam') {
            return;
        }

        if (get_comment_meta($comment_id, self::COMMENT_META_NOTIFIED, true)) {
            return;
        }

        if ((string) $comment->comment_approved === '0') {
            if (function_exists('wp_new_comment_notify_moderator')) {
                wp_new_comment_notify_moderator($comment_id);
                update_comment_meta($comment_id, self::COMMENT_META_NOTIFIED, 1);
            }
        } elseif ((string) $comment->comment_approved === '1') {
            if (function_exists('wp_new_comment_notify_postauthor')) {
                wp_new_comment_notify_postauthor($comment_id);
                update_comment_meta($comment_id, self::COMMENT_META_NOTIFIED, 1);
            }
        }
    }

    private static function record_blocked_ip(\WP_Comment $comment): void {
        $ip = trim((string) $comment->comment_author_IP);
        if ($ip === '') {
            return;
        }

        $ip_key = strtolower($ip);
        $strikes = self::increment_ip_strike($ip_key);

        if ($strikes >= 2) {
            self::ban_ip($ip_key);
        }
    }

    private static function ban_ip(string $ip): void {
        self::remove_ip_from_counts($ip);

        $current = (string) get_option('disallowed_keys', '');
        $lines = preg_split('/\r?\n/', $current);
        if (!is_array($lines)) {
            $lines = [];
        }

        $unique = [];
        foreach ($lines as $line) {
            $line = trim($line);
            if ($line === '') {
                continue;
            }
            $unique[strtolower($line)] = $line;
        }

        if (!isset($unique[strtolower($ip)])) {
            $unique[strtolower($ip)] = $ip;
        }

        $values = array_values($unique);
        sort($values, SORT_NATURAL | SORT_FLAG_CASE);

        $new_value = implode("\n", $values);
        if ($new_value !== '') {
            $new_value .= "\n";
        }

        update_option('disallowed_keys', $new_value);
    }


    private static function increment_ip_strike(string $ip): int {
        global $wpdb;

        $option = self::OPTION_IP_COUNTS;
        $marker = (object) [];

        for ($attempt = 0; $attempt < 5; $attempt++) {
            $raw = get_option($option, $marker);
            $exists = $raw !== $marker;
            $counts = ($exists && is_array($raw)) ? $raw : [];

            $current = isset($counts[$ip]) ? (int) $counts[$ip] : 0;
            $counts[$ip] = $current + 1;

            if (!$exists) {
                if (add_option($option, $counts, '', 'no')) {
                    wp_cache_delete($option, 'options');
                    return $counts[$ip];
                }
            } else {
                $old_serialized = maybe_serialize($raw);
                $new_serialized = maybe_serialize($counts);
                $updated = $wpdb->query(
                    $wpdb->prepare(
                        "UPDATE {$wpdb->options} SET option_value = %s WHERE option_name = %s AND option_value = %s",
                        $new_serialized,
                        $option,
                        $old_serialized
                    )
                );

                if ($updated) {
                    wp_cache_delete($option, 'options');
                    return $counts[$ip];
                }
            }

            wp_cache_delete($option, 'options');
            usleep(self::jitter(20000, 30000));
        }

        $counts = get_option($option, []);
        if (!is_array($counts)) {
            $counts = [];
        }
        $counts[$ip] = isset($counts[$ip]) ? (int) $counts[$ip] + 1 : 1;
        update_option($option, $counts, false);
        return (int) $counts[$ip];
    }

    private static function remove_ip_from_counts(string $ip): void {
        global $wpdb;

        $option = self::OPTION_IP_COUNTS;
        $marker = (object) [];

        for ($attempt = 0; $attempt < 5; $attempt++) {
            $raw = get_option($option, $marker);
            if ($raw === $marker || !is_array($raw) || !isset($raw[$ip])) {
                return;
            }

            $counts = $raw;
            unset($counts[$ip]);
            $old_serialized = maybe_serialize($raw);

            if (empty($counts)) {
                $deleted = $wpdb->query(
                    $wpdb->prepare(
                        "DELETE FROM {$wpdb->options} WHERE option_name = %s AND option_value = %s LIMIT 1",
                        $option,
                        $old_serialized
                    )
                );

                if ($deleted) {
                    wp_cache_delete($option, 'options');
                    return;
                }
            } else {
                $new_serialized = maybe_serialize($counts);
                $updated = $wpdb->query(
                    $wpdb->prepare(
                        "UPDATE {$wpdb->options} SET option_value = %s WHERE option_name = %s AND option_value = %s",
                        $new_serialized,
                        $option,
                        $old_serialized
                    )
                );

                if ($updated) {
                    wp_cache_delete($option, 'options');
                    return;
                }
            }

            wp_cache_delete($option, 'options');
            usleep(self::jitter(20000, 30000));
        }

        $counts = get_option($option, []);
        if (!is_array($counts) || !isset($counts[$ip])) {
            return;
        }

        unset($counts[$ip]);

        if (!empty($counts)) {
            update_option($option, $counts, false);
        } else {
            delete_option($option);
        }
    }

    private static function acquire_worker_slot() {
        $uploads = wp_upload_dir();

        if (!empty($uploads['error'])) {
            self::log_lock_issue('Unable to access uploads directory: ' . $uploads['error']);
            $fallback = self::acquire_transient_lock();
            if ($fallback === null) {
                return null;
            }

            if ($fallback === false) {
                return false;
            }

            return $fallback;
        }

        $basedir = $uploads['basedir'] ?? '';
        if (empty($basedir)) {
            self::log_lock_issue('Uploads base directory is not available.');
            $fallback = self::acquire_transient_lock();
            if ($fallback === null) {
                return null;
            }

            if ($fallback === false) {
                return false;
            }

            return $fallback;
        }

        $lock_dir = trailingslashit($basedir) . self::LOCK_DIR_NAME;

        if (!is_dir($lock_dir) && !wp_mkdir_p($lock_dir)) {
            self::log_lock_issue('Failed to create lock directory: ' . $lock_dir);
            $fallback = self::acquire_transient_lock();
            if ($fallback === null) {
                return null;
            }

            if ($fallback === false) {
                return false;
            }

            return $fallback;
        }

        if (!is_writable($lock_dir)) {
            self::log_lock_issue('Lock directory is not writable: ' . $lock_dir);
            $fallback = self::acquire_transient_lock();
            if ($fallback === null) {
                return null;
            }

            if ($fallback === false) {
                return false;
            }

            return $fallback;
        }

        for ($slot = 0; $slot < self::MAX_ACTIVE_WORKERS; $slot++) {
            $lock_path = trailingslashit($lock_dir) . 'slot-' . $slot . '.lock';
            $handle = @fopen($lock_path, 'c');

            if (!$handle) {
                self::log_lock_issue('Failed to open lock file: ' . $lock_path);
                continue;
            }

            if (@flock($handle, LOCK_EX | LOCK_NB)) {
                self::$lockHandles[$lock_path] = $handle;
                return $lock_path;
            }

            fclose($handle);
        }

        $fallback = self::acquire_transient_lock();
        if ($fallback === null) {
            return null;
        }

        if ($fallback === false) {
            return false;
        }

        return $fallback;
    }

    private static function release_worker_slot($lock_path): void {
        if (!is_string($lock_path)) {
            return;
        }

        if ($lock_path === self::TRANSIENT_LOCK_KEY) {
            delete_transient(self::TRANSIENT_LOCK_KEY);
            unset(self::$lockHandles[$lock_path]);
            return;
        }

        if (empty(self::$lockHandles[$lock_path])) {
            return;
        }

        $handle = self::$lockHandles[$lock_path];
        if (is_resource($handle)) {
            @flock($handle, LOCK_UN);
            fclose($handle);
        }
        unset(self::$lockHandles[$lock_path]);
    }

    private static function acquire_transient_lock() {
        $key = self::TRANSIENT_LOCK_KEY;

        if (false !== get_transient($key)) {
            return null;
        }

        if (set_transient($key, 1, self::LOCK_RETRY_DELAY + 30)) {
            self::$lockHandles[$key] = true;
            return $key;
        }

        return false;
    }

    private static function jitter(int $base, int $spread): int {
        if ($spread <= 0) {
            return $base;
        }

        try {
            $offset = random_int(0, $spread);
        } catch (\Exception $e) {
            $offset = mt_rand(0, $spread);
        }

        return $base + $offset;
    }

    private static function log_lock_issue(string $message): void {
        if (self::$lockWarningLogged) {
            return;
        }

        self::$lockWarningLogged = true;
        error_log('[OpenRouter Spam Filter] ' . $message);
    }

    private static function classify_comment(string $comment_content): ?array {
        $api_key = getenv('OPENROUTER_API_KEY');
        if (!$api_key && defined('OPENROUTER_API_KEY')) {
            $api_key = OPENROUTER_API_KEY;
        }

        if (!$api_key) {
            return null;
        }

        foreach (self::MODELS as $model) {
            for ($attempt = 1; $attempt <= self::MAX_ATTEMPTS_PER_MODEL; $attempt++) {
                $response = self::query_openrouter($model, $comment_content, $api_key);

                if (is_wp_error($response)) {
                    continue;
                }

                $status_code = (int) wp_remote_retrieve_response_code($response);
                if ($status_code < 200 || $status_code >= 300) {
                    continue;
                }

                $body = wp_remote_retrieve_body($response);
                if (!$body) {
                    continue;
                }

                $parsed = json_decode($body, true);
                if (!is_array($parsed) || empty($parsed['choices'][0]['message']['content'])) {
                    continue;
                }

                $content = trim($parsed['choices'][0]['message']['content']);

                $decision = self::parse_model_response($content);
                if ($decision !== null) {
                    return $decision;
                }
            }
        }

        return null;
    }

    private static function query_openrouter(string $model, string $comment_content, string $api_key) {
        $payload = [
            'model' => $model,
            'response_format' => ['type' => 'json_object'],
            'messages' => [
                [
                    'role' => 'system',
                    'content' => self::SYSTEM_PROMPT,
                ],
                [
                    'role' => 'user',
                    'content' => self::build_user_prompt($comment_content),
                ],
            ],
        ];

        $headers = [
            'Authorization' => 'Bearer ' . $api_key,
            'Content-Type' => 'application/json',
        ];

        $referer = home_url();
        if (!empty($referer)) {
            $headers['Referer'] = $referer;
        }

        $title = get_bloginfo('name');
        if (!empty($title)) {
            $headers['X-Title'] = $title;
        }

        return wp_remote_post(
            self::API_ENDPOINT,
            [
                'timeout' => 20,
                'headers' => $headers,
                'body' => wp_json_encode($payload),
            ]
        );
    }

    private static function build_user_prompt(string $comment_content): string {
        $encoded = wp_json_encode($comment_content, JSON_UNESCAPED_UNICODE);
        if ($encoded === false) {
            $encoded = '""';
        }

        return "Classify the following comment. Respond with JSON in the format {\"is_spam\": <bool>, \"confidence\": <float>} with no additional text.\n\nComment: {$encoded}";
    }

    private static function parse_model_response(string $content): ?array {
        $decoded = json_decode($content, true);
        if (!is_array($decoded)) {
            return null;
        }

        if (!array_key_exists('is_spam', $decoded) || !array_key_exists('confidence', $decoded)) {
            return null;
        }

        $is_spam = filter_var($decoded['is_spam'], FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);
        if ($is_spam === null) {
            return null;
        }

        $confidence = is_numeric($decoded['confidence']) ? (float) $decoded['confidence'] : null;
        if ($confidence === null) {
            return null;
        }

        return [
            'is_spam' => (bool) $is_spam,
            'confidence' => $confidence,
        ];
    }
}

OpenRouter_Spam_Filter::init();
